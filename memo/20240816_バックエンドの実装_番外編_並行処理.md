# バックエンドの実装 番外編：並行処理
Go の大きな特徴として、組み込みの文法だけで簡単に並列処理を実現できる点があげられます。
他の言語では馴染みのない機能で使い慣れないので、簡単に使い方をまとめてきます。

## ゴルーチン
ゴルーチンは、任意の関数やメソッドの呼び出しの前に ```go``` を付けるだけでゴルーチンが作成され、並行処理が開始されます。

```go
go func() {
    // 並列処理したいコード
} ()
```

ゴルーチンには以下のような特徴があります。

- 個々のゴルーチンに親子関係や優先度はなく、識別することもできない
- 外部から終了させることはできず、終了を検知するにも別の仕組みが必要となる
- 起動は高速でメモリ消費も少ないが、起動コストはゼロではない

特に3つ目の特徴は分かりづらいバグを生む原因となりため注意が必要です。
例えば、ゴルーチンを作成している間に ```main``` 関数を抜けて処理が終了してしまっているため、以下のコードはゴルーチン内の処理は実行されません。

```go
func main() {
	go func() {
		fmt.Println("ゴルーチン内で実行しています")
	}()
	fmt.Println("ゴルーチンが終了しました")
}
```

## チャネル
チャネルはゴルーチンから送受信できるキューで、データの喪失や重複した送信がないことが保証された組み込み機能です。
チャンネルを使うことで安全なデータの受け渡しや、待ち合わせを実現できます。
チャネルにはバッファの有無によって2種類あります。

- バッファなしチャネル (デフォルト)
  - 送信ゴルーチンと受信ゴルーチンがそろうまで処理をブロックし、そろったタイミングでデータの受け渡しを行う
  - 送信だけ、受信だけがある場合にはどちらもブロックする
  - 送受信ともにゴルーチン数に制限はない
- バッファありチャネル
  - バッファの数だけ内容を保持できる
  - 送信側のバッファがいっぱいになったら、受信側が取りに来るまでチャネルをブロックする
  - 送信側だけの場合はブロックせず処理を継続する
  - バッファが空の場合は受信しようとしてもブロックする

### チャネルの作成
チャネルは ```make``` 関数で作成します。
第2引数にバッファサイズを指定すればバッファあり、指定しなければバッファなしになります。

```go
// バッファなし int チャネル
ic := make(chan int)

// バッファあり string チャネル (容量：10)
sc := make(chan string, 10)
```

### チャネルを介した送信と受信
チャネルを介したデータの送受信には ```<-``` 演算子を利用します。
チャネルを左辺に置き、データを右辺に置けば送信、チャネルを右辺に、データを左辺に置けば受信になります。
送信の書き方は1種類しかありませんが、受信には用途に応じて3種類の書き方があります。

```go
// チャネルに送信
ic <- 100

// チャネルから受信：データは捨てる
<-sc

// チャネルから受信：送信結果を変数に代入
r := <-sc

// チャネルから受信：送信結果とチャネル状態を変数に代入
r, ok := <-sc
```

上記の ```ok``` には、チャネルがアクティブな場合は ```true``` が、クローズ済みの場合は ```false``` が入ります。

### チャネルのクローズ
チャネルは ```close``` 関数でクローズします。
クローズ済みのチャネルから受信しようとするとゼロ値が返ってきます。
一方、クローズ済みのチャネルに送信しようとしたり、再度クローズしたりしようとすると ```panic``` が発生します。
現状、チャネルがクローズされているかを確認する手段は用意されていないので、送信側のゴルーチンで責任をもってクローズする必要があります。

### for ループを使ったデータの受信
チャネルと for ループを組み合わせることで、チャネルをスライスのように扱うことができます。
ただし、```range``` を使って取り出すときにインデックスはなく、実データだけが取り出されます。

```go
func main() {
	ic := make(chan int)

	go func() {
		ic <- 10
		ic <- 20
		close(ic)
	}()

	for v := range ic {
		fmt.Println(v)
	}
}
```

### 用途を限定したチャネルの作成
チャネルの型は ```chan <data type>``` で宣言できますが、```chan``` キーワードの左右に ```<-``` を置くことで、受信専用、送信専用と用途を限定することも可能です。

```go
// 送信専用
s chan<- string

// 受信専用
r <-chan string
```