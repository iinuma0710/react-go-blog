# バックエンドの実装 その17
これまで、書籍 (詳解 Go 言語) に沿って、実装を進めてきました。
これからも、その方針は変わりませんが、復習も兼ねて自分なりに整理しながらユーザの登録機能を実装していきます。

## 現状のディレクトリ構成
テスト関連のコードや設定を読み込むコードを除くと、```backend``` ディレクトリ内は以下のようになっています。

```
backend/
├── entity/
│   └── article.go
├── handler/
│   ├── add_article.go
│   ├── list_article.go
│   ├── response.go
│   └── service.go
├── service/
│   ├── add_article.go
│   ├── interface.go
│   └── list_article.go
├── store/
│   ├── article.go
│   ├── repository.go
│   └── store.go
├── main.go
├── mux.go
└── server.go
```

詳解 Go 言語の著者曰く、常にベストなアーキテクチャがあるわけではないため「DDDやクリーンアーキテクチャに類するパッケージ構成などの解説はあえてしていません」([My External Strage](https://budougumi0617.github.io/2022/07/22/release_go_web_application_book/) より) とのことですが、今後の実装のためにも各パッケージごとの役割を明確にしておきたいと思います。

## ```entity``` パッケージ
```entity``` パッケージは、データベースの各テーブルに対応する構造体型を定義するパッケージです。
例えば、ユーザ情報を保持する ```User``` 構造体は以下のように定義されます。

```backend/entity/user.go```
```go
package entity

import "time"

type UserID int64

type User struct {
	ID        UserID    `json:"id" db:"id"`
	Name      string    `json:"name" db:"name"`
	Password  string    `json:"wassword" db:"password"`
	Role      string    `json:"role" db:"role"`
	CreatedAt time.Time `json:"created_at" db:"created_at"`
	UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}
```

構造体の各フィールドには、API でデータをやり取りするときに使う JSON のフィールド名を指定する ```json``` タグと、```sqlx``` でデータベースと情報をやり取りするときに必要な ```db``` タグをそれぞれ付与しています。
また、```type UserID int64``` のように、主キーとなるようなフィールドの型に別名を与えておくと、他の構造体の主キーと混同するミスを防ぐことができます。

## ```mux.go``` と ```handler``` パッケージ
```mux.go``` と ```handler``` パッケージには、

1. ```mux.go``` に定義されたパスへのリクエストを受け付ける
2. リクエストボディから JSON を生成し、有効なリクエストか検証する
3. リクエストを実行し、実行結果を含めたレスポンスを返す

という役割があります。

### 1. リクエストの受付
```handler``` パッケージのあるファイルには、1つの HTTP ハンドラに対応する構造体と、具体的な処理を記述したメソッドを定義します。
たとえば、ユーザ登録を行う HTTP ハンドラを定義した ```register_user.go``` には、以下のような構造体が定義されています。

```backend/handler/register_user.go```
```go
type RegisterUser struct {
	Service   RegisterUserService
	Validator *validator.Validate
}

func (ru *RegisterUser) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	...
}
```

```RegisterUser``` 構造体の ```Service``` フィールドは、```handler/service.go``` に定義されたインターフェースを満たす値が入ります。
おそらく、この部分は必ずしもインターフェースを介する必要はなく、直接 ```service``` パッケージで定義された構造体の型を指定しても良いのだと思いますが、```github.com/matryer/moq``` を使ってテスト用のモックを生成できます。

```backend/handler/service.go```
```go
type RegisterUserService interface {
	RegisterUser(ctx context.Context, name, password, role string) (*entity.User, error)
}
```

また、```Validator``` フィールドは、リクエストの JSON の有効性をチェックする ```*validator.Validate``` 型となっており、一覧のリストを取得するように JSON を受け取らないリクエストの場合には省略可能です。  
```mux.go``` の ```NewMux``` 関数内において、上記で定義した構造体のインスタンスを作成し、API のパスと ```ServeHTTP``` メソッドを紐づけてリクエストを受け付けています。

```backend/mux.go```
```go
ru := &handler.RegisterUser{
	Service:   &service.RegisterUser{DB: db, Repo: &r},
	Validator: v,
}
mux.Post("/register", ru.ServeHTTP)
```

### 2. JSON の生成と検証
```handler``` パッケージの各 ```ServeHTTP``` メソッドでは、まずリクエストボディから Go の ```json``` パッケージを使ってリクエストの JSON を取り出します。
以下は、その処理の一例です。まず、リクエストボディから取り出す JSON の構造体を定義します。

```go
var b struct {
	Name     string `json:"name" validate:"required"`
	Password string `json:"password" validate:"required"`
	Role     string `json:"role" validate:"required"`
}
```

次に、各フィールドに付与された ```json``` タグをもとにデコード処理を行い、デコード処理に失敗した場合にはエラーを含めたレスポンスを返します。 

```go
if err := json.NewDecoder(r.Body).Decode(&b); err != nil {
	RespondJSON(ctx, w, &ErrResponse{
		Message: err.Error(),
	}, http.StatusInternalServerError)
	return
}
```
 
その後、```github.com/go-playground/validator``` パッケージを使って、```validate``` タグの情報をもとに有効なリクエストか検証を行います。
もし、リクエストに必要な情報が欠けているなどの理由でエラーが返ってきた場合には、```StatusBadRequest``` を返しています。

```go
if err := ru.Validator.Struct(b); err != nil {
	RespondJSON(ctx, w, &ErrResponse{
		Message: err.Error(),
	}, http.StatusBadRequest)
	return
}
```

### 3. リクエストの実行とレスポンス
有効なリクエストが得られたら、最初に定義した構造体の ```Service``` フィールドの値の持つメソッドを呼び出して、リクエストを実行します。
具体的な処理の内容については ```service``` パッケージの責務としています。
このタイミングでエラーが発生した場合には、```StatusInternalServerError``` としてレスポンスを返します。

```go
u, err := ru.Service.RegisterUser(ctx, b.Name, b.Password, b.Role)
if err != nil {
	RespondJSON(ctx, w, &ErrResponse{
		Message: err.Error(),
	}, http.StatusInternalServerError)
	return
}
```

最後に、エラーなくリクエストの実行が完了したら、実行結果をレスポンスに含めて返します。

```go
rsp := struct {
	ID entity.UserID `json:"id"`
}{ID: u.ID}
RespondJSON(ctx, w, rsp, http.StatusOK)
```

レスポンスを返すときに呼び出している ```RespondJSON``` は、```backend/handler/response.go``` に定義されています。

## ```service``` パッケージ
```service``` パッケージには、いわゆる「ビジネスロジック」を記述します。
「ビジネスロジック」という表現は大雑把で分かりづらいのですが、言い換えればリクエストの待ち受けやレスポンスの返信、データベースとのやり取り以外の処理のことを指すのでしょうか？
これまでに実装した処理では、あまり複雑なことをしていないのですが、例えばパスワードのハッシュ化などが該当すると思います。  
```service``` パッケージの各ファイルには、```store``` パッケージで定義されたデータベース関連の処理をまとめたインターフェースを満たす値を格納する ```DB``` フィールドと、```interface.go``` に定義されたインターフェースを満たす値を格納する 値を格納する ```Repo``` フィールドを持つ構造体を定義しています。

```go
type AddArticle struct {
	DB   store.Execer
	Repo ArticleAdder
}
```

それぞれのフィールドの値は、```mux.go``` でインスタンス化された、```*sqlx.DB``` 型の値と ```store.Repository``` 型の値を格納します。  
```interface.go``` には、各ファイルでデータベースに処理を投げるときに呼び出すメソッドを持つインターフェースを定義しています。
このインターフェースを定義しておくことで、```handler``` パッケージと同様に、```github.com/matryer/moq``` を使ってテスト用のモックを生成できます。

```go
type ArticleAdder interface {
	AddArticle(ctx context.Context, db store.Execer, a *entity.Article) error
}
```

## ```store``` パッケージ
```store``` パッケージでは、データベースにデータを保存したり、読み込んだりする処理を行います。
これまでの実装では、GORM のようなパッケージは使わず、生 SQL を記述して ```github.com/jmoiron/sqlx``` パッケージの ```*sqlx.DB``` 型のメソッドを呼び出してクエリを実行しています。
また、すべてのメソッドは ```Repository``` 構造体のレシーバとして定義します。

```go
func (r *Repository) ListArticles(ctx context.Context, db Queryer) (entity.Articles, error) {
	articles := entity.Articles{}
	sql := `SELECT id, title, status, created_at FROM article;`

	if err := db.SelectContext(ctx, &articles, sql); err != nil {
		return nil, err
	}

	return articles, nil
}
```

また、```repository.go``` にデータベースとの接続を開始する ```New``` 関数や ```Repository``` 構造体、```service``` パッケージで定義する構造体の ```Repo``` フィールドが満たすべきインターフェースなどを定義しています。