// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"context"
	"github.com/iinuma0710/react-go-blog/backend/entity"
	"github.com/iinuma0710/react-go-blog/backend/store"
	"sync"
)

// Ensure, that ArticleAdderMock does implement ArticleAdder.
// If this is not the case, regenerate this file with moq.
var _ ArticleAdder = &ArticleAdderMock{}

// ArticleAdderMock is a mock implementation of ArticleAdder.
//
//	func TestSomethingThatUsesArticleAdder(t *testing.T) {
//
//		// make and configure a mocked ArticleAdder
//		mockedArticleAdder := &ArticleAdderMock{
//			AddArticleFunc: func(ctx context.Context, db store.Execer, a *entity.Article) error {
//				panic("mock out the AddArticle method")
//			},
//		}
//
//		// use mockedArticleAdder in code that requires ArticleAdder
//		// and then make assertions.
//
//	}
type ArticleAdderMock struct {
	// AddArticleFunc mocks the AddArticle method.
	AddArticleFunc func(ctx context.Context, db store.Execer, a *entity.Article) error

	// calls tracks calls to the methods.
	calls struct {
		// AddArticle holds details about calls to the AddArticle method.
		AddArticle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Execer
			// A is the a argument value.
			A *entity.Article
		}
	}
	lockAddArticle sync.RWMutex
}

// AddArticle calls AddArticleFunc.
func (mock *ArticleAdderMock) AddArticle(ctx context.Context, db store.Execer, a *entity.Article) error {
	if mock.AddArticleFunc == nil {
		panic("ArticleAdderMock.AddArticleFunc: method is nil but ArticleAdder.AddArticle was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Execer
		A   *entity.Article
	}{
		Ctx: ctx,
		Db:  db,
		A:   a,
	}
	mock.lockAddArticle.Lock()
	mock.calls.AddArticle = append(mock.calls.AddArticle, callInfo)
	mock.lockAddArticle.Unlock()
	return mock.AddArticleFunc(ctx, db, a)
}

// AddArticleCalls gets all the calls that were made to AddArticle.
// Check the length with:
//
//	len(mockedArticleAdder.AddArticleCalls())
func (mock *ArticleAdderMock) AddArticleCalls() []struct {
	Ctx context.Context
	Db  store.Execer
	A   *entity.Article
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Execer
		A   *entity.Article
	}
	mock.lockAddArticle.RLock()
	calls = mock.calls.AddArticle
	mock.lockAddArticle.RUnlock()
	return calls
}

// Ensure, that ArticleListerMock does implement ArticleLister.
// If this is not the case, regenerate this file with moq.
var _ ArticleLister = &ArticleListerMock{}

// ArticleListerMock is a mock implementation of ArticleLister.
//
//	func TestSomethingThatUsesArticleLister(t *testing.T) {
//
//		// make and configure a mocked ArticleLister
//		mockedArticleLister := &ArticleListerMock{
//			ListArticlesFunc: func(ctx context.Context, db store.Queryer) (entity.Articles, error) {
//				panic("mock out the ListArticles method")
//			},
//		}
//
//		// use mockedArticleLister in code that requires ArticleLister
//		// and then make assertions.
//
//	}
type ArticleListerMock struct {
	// ListArticlesFunc mocks the ListArticles method.
	ListArticlesFunc func(ctx context.Context, db store.Queryer) (entity.Articles, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListArticles holds details about calls to the ListArticles method.
		ListArticles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Db is the db argument value.
			Db store.Queryer
		}
	}
	lockListArticles sync.RWMutex
}

// ListArticles calls ListArticlesFunc.
func (mock *ArticleListerMock) ListArticles(ctx context.Context, db store.Queryer) (entity.Articles, error) {
	if mock.ListArticlesFunc == nil {
		panic("ArticleListerMock.ListArticlesFunc: method is nil but ArticleLister.ListArticles was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Db  store.Queryer
	}{
		Ctx: ctx,
		Db:  db,
	}
	mock.lockListArticles.Lock()
	mock.calls.ListArticles = append(mock.calls.ListArticles, callInfo)
	mock.lockListArticles.Unlock()
	return mock.ListArticlesFunc(ctx, db)
}

// ListArticlesCalls gets all the calls that were made to ListArticles.
// Check the length with:
//
//	len(mockedArticleLister.ListArticlesCalls())
func (mock *ArticleListerMock) ListArticlesCalls() []struct {
	Ctx context.Context
	Db  store.Queryer
} {
	var calls []struct {
		Ctx context.Context
		Db  store.Queryer
	}
	mock.lockListArticles.RLock()
	calls = mock.calls.ListArticles
	mock.lockListArticles.RUnlock()
	return calls
}
